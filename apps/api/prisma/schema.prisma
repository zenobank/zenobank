generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/**
 * ===== Enums =====
 */

enum MethodType {
  ONCHAIN
  BINANCE_PAY
}

enum CheckoutStatus {
  OPEN
  COMPLETED
  EXPIRED
  CANCELLED
}

enum AttemptStatus {
  PENDING
  PROCESSING
  SUCCEEDED
  FAILED
  CANCELLED
}

enum PaymentStatus {
  PENDING
  PROCESSING
  COMPLETED
  EXPIRED
  CANCELLED
}

enum NetworkType {
  EVM
  SOLANA
}

/**
 * ===== Usuarios & Tiendas =====
 */

model User {
  id        String   @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  stores    Store[]
}

model Store {
  id        String   @id @default(cuid())
  name      String   @default("Default Store")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  apiKey    String   @unique
  userId    String
  user      User     @relation(fields: [userId], references: [id])

  // Credenciales por proveedor

  // onchain
  wallets Wallet[]

  // Pagos (finales) y checkouts
  payments             Payment[]
  checkouts            Checkout[]
  binancePayCredential BinancePayCredential?
}

/**
 * Credenciales por proveedor (1 por store y proveedor)
 */

/**
 * ===== Checkout → Attempt → Payment =====
 */

model Checkout {
  id            String         @id @default(cuid())
  orderId       String
  priceCurrency String
  priceAmount   String
  status        CheckoutStatus @default(OPEN)
  expiresAt     DateTime?      @default(dbgenerated("now() + interval '1 hour'"))

  storeId String
  store   Store  @relation(fields: [storeId], references: [id])

  onChainPaymentAttempts OnChainPaymentAttempt[]
  binancePayAttempts     BinancePayPaymentAttempt[]

  // back-ref 1–1 desde Payment (relación nombrada)
  payment Payment? @relation("CheckoutPayment")

  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt
  onchainToken      OnchainToken?    @relation(fields: [onchainTokenId], references: [id])
  onchainTokenId    String?
  binancePayToken   BinancePayToken? @relation(fields: [binancePayTokenId], references: [id])
  binancePayTokenId String?
}

/**
 * Cada elección/reintento del usuario
 */

model OnChainPaymentAttempt {
  id              String        @id @default(cuid())
  status          AttemptStatus @default(PENDING)
  transactionHash String?
  tokenPayAmount  String

  tokenId String

  depositWalletId String
  checkoutId      String
  networkId       String

  checkout      Checkout     @relation(fields: [checkoutId], references: [id])
  token         OnchainToken @relation(fields: [tokenId], references: [id])
  network       Network      @relation(fields: [networkId], references: [id])
  depositWallet Wallet       @relation(fields: [depositWalletId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  payment   Payment?

  @@unique([checkoutId, tokenId])
}

model BinancePayPaymentAttempt {
  id             String          @id @default(cuid())
  status         AttemptStatus   @default(PENDING)
  tokenPayAmount String
  tokenId        String
  checkoutId     String
  transactionId  String?
  paidAt         DateTime?
  checkout       Checkout        @relation(fields: [checkoutId], references: [id])
  payment        Payment?
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
  token          BinancePayToken @relation(fields: [tokenId], references: [id])

  @@unique([checkoutId, tokenId])
}

/**
 * Pago final, sólo cuando un intento SUCCEEDED
 */
model Payment {
  id        String        @id @default(cuid())
  status    PaymentStatus @default(PENDING)
  paidAt    DateTime?
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt

  onchainAttemptId String? @unique
  binanceAttemptId String? @unique

  onchainAttempt OnChainPaymentAttempt?    @relation(fields: [onchainAttemptId], references: [id])
  binanceAttempt BinancePayPaymentAttempt? @relation(fields: [binanceAttemptId], references: [id])

  checkoutId String   @unique
  checkout   Checkout @relation("CheckoutPayment", fields: [checkoutId], references: [id])

  storeId String
  store   Store  @relation(fields: [storeId], references: [id])

  @@index([storeId, status])
}

/**
 * ===== Infra onchain existente =====
 */

model Network {
  id                      String      @id
  networkType             NetworkType
  name                    String      @unique
  displayName             String
  isTestnet               Boolean
  createdAt               DateTime    @default(now())
  updatedAt               DateTime    @updatedAt
  confirmationRetryDelay  Int         @default(1000)
  maxConfirmationAttempts Int         @default(100)
  minBlockConfirmations   Int         @default(3)

  onChainTokens          OnchainToken[]
  wallets                Wallet[]
  onChainPaymentAttempts OnChainPaymentAttempt[]
}

/**
 * ProviderToken.id and Token.id must be different
 */

model OnchainToken {
  id               String @id
  canonicalTokenId String
  address          String
  decimals         Int
  symbol           String

  networkId String

  checkouts Checkout[]
  logoUrl   String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  network               Network                 @relation(fields: [networkId], references: [id])
  OnChainPaymentAttempt OnChainPaymentAttempt[]

  @@unique([networkId, address])
  @@index([canonicalTokenId])
  @@index([networkId, symbol])
}

model BinancePayCredential {
  id        String   @id @default(uuid())
  storeId   String
  store     Store    @relation(fields: [storeId], references: [id])
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  apiKey    String
  apiSecret String

  accountId String

  @@unique([storeId])
}

model BinancePayToken {
  id               String @id
  canonicalTokenId String
  binanceTokenId   String
  symbol           String

  name      String
  logoUrl   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  checkouts                Checkout[]
  BinancePayPaymentAttempt BinancePayPaymentAttempt[]

  @@unique([canonicalTokenId])
}

model Wallet {
  id        String   @id @default(uuid())
  address   String
  networkId String
  label     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  storeId   String?

  network                Network                 @relation(fields: [networkId], references: [id])
  store                  Store?                  @relation(fields: [storeId], references: [id])
  onChainPaymentAttempts OnChainPaymentAttempt[]

  @@unique([networkId, address])
}
