generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/**
 * ===== Enums =====
 */

enum PaymentRail {
  ONCHAIN
  CUSTODIAL
}

enum Provider {
  BINANCE_PAY
}

enum CheckoutStatus {
  OPEN
  COMPLETED
  EXPIRED
  CANCELLED
}

enum AttemptStatus {
  PENDING
  PROCESSING
  SUCCEEDED
  FAILED
  EXPIRED
}

enum PaymentStatus {
  PENDING
  PROCESSING
  COMPLETED
  EXPIRED
  CANCELLED
}

enum NetworkType {
  EVM
  SOLANA
}

enum TokenStandard {
  NATIVE
  ERC20
  SPL
}

/**
 * ===== Usuarios & Tiendas =====
 */

model User {
  id        String   @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  stores    Store[]
}

model Store {
  id        String   @id @default(cuid())
  name      String   @default("Default Store")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  apiKey    String   @unique @default(cuid())

  userId String
  user   User   @relation(fields: [userId], references: [id])

  // Credenciales por proveedor
  credentials StoreCredential[]

  // On-chain
  wallets Wallet[]

  // Pagos (finales) y checkouts
  payments  Payment[]
  checkouts Checkout[]
}

/**
 * Credenciales por proveedor (1 por store y proveedor)
 */
model StoreCredential {
  id        String   @id @default(uuid())
  provider  Provider
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  apiKey    String
  apiSecret String

  storeId String
  store   Store  @relation(fields: [storeId], references: [id])

  binancePayments BinancePayPayment[]

  @@unique([storeId, provider])
}

/**
 * ===== Checkout → Attempt → Payment =====
 */

model Checkout {
  id            String         @id @default(cuid())
  orderId       String
  priceCurrency String
  priceAmount   String
  status        CheckoutStatus @default(OPEN)
  expiresAt     DateTime?      @default(dbgenerated("now() + interval '1 hour'"))

  storeId String
  store   Store  @relation(fields: [storeId], references: [id])

  attempts              PaymentAttempt[]
  enabledTokens         Token[]
  enabledProviderTokens ProviderToken[]
  enabledRails          PaymentRail[]

  // back-ref 1–1 desde Payment (relación nombrada)
  payment Payment? @relation("CheckoutPayment")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([storeId, orderId])
}

/**
 * Cada elección/reintento del usuario
 */
model PaymentAttempt {
  id         String   @id @default(cuid())
  checkoutId String
  checkout   Checkout @relation(fields: [checkoutId], references: [id])

  rail   PaymentRail
  status AttemptStatus @default(PENDING)

  // ONCHAIN
  onchain OnchainAttempt?

  // BINANCE_PAY
  binancePay BinancePayPayment?

  // back-ref al Payment final (1–1) si este attempt gana
  payment Payment? @relation("AttemptPayment")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([checkoutId, status])
  @@index([rail, status])
}

/**
 * Detalle del intento ONCHAIN
 */
model OnchainAttempt {
  id              String  @id @default(uuid())
  attemptId       String  @unique
  transactionHash String?
  tokenId         String
  tokenPayAmount  String

  networkId       String
  depositWalletId String

  attempt PaymentAttempt @relation(fields: [attemptId], references: [id])
  network Network        @relation(fields: [networkId], references: [id])
  wallet  Wallet         @relation(fields: [depositWalletId], references: [id])
  token   Token          @relation(fields: [tokenId], references: [id])
}

/**
 * Detalle del intento BINANCE PAY
 */
model BinancePayPayment {
  id        String @id @default(uuid())
  attemptId String @unique

  credentialId String

  tokenPayAmount String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  attempt    PaymentAttempt  @relation(fields: [attemptId], references: [id])
  credential StoreCredential @relation(fields: [credentialId], references: [id])
}

/**
 * Pago final, sólo cuando un intento SUCCEEDED
 */
model Payment {
  id        String        @id @default(cuid())
  status    PaymentStatus @default(PENDING)
  paidAt    DateTime?
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt

  // Intento ganador (inmutable) – relación 1–1 nombrada
  attemptId String         @unique
  attempt   PaymentAttempt @relation("AttemptPayment", fields: [attemptId], references: [id])

  // Relación directa al checkout (1–1) – nombrada
  checkoutId String   @unique
  checkout   Checkout @relation("CheckoutPayment", fields: [checkoutId], references: [id])

  // Copias para reporting (foto histórica)
  orderId       String
  priceCurrency String
  priceAmount   String
  rail          PaymentRail

  storeId String
  store   Store  @relation(fields: [storeId], references: [id])

  @@index([storeId, status])
}

/**
 * ===== Infra on-chain existente =====
 */

model Network {
  id                      String      @id
  networkType             NetworkType
  name                    String      @unique
  displayName             String
  isTestnet               Boolean
  createdAt               DateTime    @default(now())
  updatedAt               DateTime    @updatedAt
  confirmationRetryDelay  Int         @default(1000)
  maxConfirmationAttempts Int         @default(100)
  minBlockConfirmations   Int         @default(3)

  tokens          Token[]
  wallets         Wallet[]
  onchainAttempts OnchainAttempt[]
}

/**
 * ProviderToken.id and Token.id must be different
 */

/**
 * ProviderToken.id and Token.id must be different
 */
/**
 * model for provider tokens
 */
model ProviderToken {
  id       String   @id
  provider Provider

  providerTokenId  String
  canonicalTokenId String
  logoUrl          String
  checkoutId       String?

  checkout Checkout? @relation(fields: [checkoutId], references: [id])

  @@unique([provider, providerTokenId])
}

/**
 * Token.id and ProviderToken.id must be different
 */
model Token {
  id               String        @id
  canonicalTokenId String
  standard         TokenStandard
  address          String
  decimals         Int
  symbol           String
  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt
  networkId        String

  checkoutId String?
  logoUrl    String

  network         Network          @relation(fields: [networkId], references: [id])
  checkout        Checkout?        @relation(fields: [checkoutId], references: [id])
  onchainAttempts OnchainAttempt[]

  @@unique([networkId, address])
  @@index([canonicalTokenId])
  @@index([networkId, symbol])
}

model Wallet {
  id        String   @id @default(uuid())
  address   String
  networkId String
  label     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  storeId   String?

  network         Network          @relation(fields: [networkId], references: [id])
  store           Store?           @relation(fields: [storeId], references: [id])
  onchainAttempts OnchainAttempt[]

  @@unique([networkId, address])
}
