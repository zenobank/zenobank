/**
 * Generated by orval v7.11.2 üç∫
 * Do not edit manually.
 * API Docs
 * API description
 * OpenAPI spec version: 1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import * as axios from 'axios';
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios';

import type {
  CreatePaymentDto,
  CreateTestDto,
  NetworkResponseDto,
  PaymentResponseDto,
  TokenResponseDto,
  UpdateDepositSelectionDto,
  WalletControllerGetValidatorSchemaV1200,
  WalletControllerTestV1200
} from './model';

export const appControllerGetHelloV1 = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    
    
    return axios.default.get(
      `/api/v1`,{
        responseType: 'text',
    ...options,}
    );
  }


export const getAppControllerGetHelloV1QueryKey = () => {
    return [`/api/v1`] as const;
    }

    
export const getAppControllerGetHelloV1QueryOptions = <TData = Awaited<ReturnType<typeof appControllerGetHelloV1>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHelloV1>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAppControllerGetHelloV1QueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof appControllerGetHelloV1>>> = ({ signal }) => appControllerGetHelloV1({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHelloV1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AppControllerGetHelloV1QueryResult = NonNullable<Awaited<ReturnType<typeof appControllerGetHelloV1>>>
export type AppControllerGetHelloV1QueryError = AxiosError<unknown>


export function useAppControllerGetHelloV1<TData = Awaited<ReturnType<typeof appControllerGetHelloV1>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHelloV1>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof appControllerGetHelloV1>>,
          TError,
          Awaited<ReturnType<typeof appControllerGetHelloV1>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAppControllerGetHelloV1<TData = Awaited<ReturnType<typeof appControllerGetHelloV1>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHelloV1>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof appControllerGetHelloV1>>,
          TError,
          Awaited<ReturnType<typeof appControllerGetHelloV1>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAppControllerGetHelloV1<TData = Awaited<ReturnType<typeof appControllerGetHelloV1>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHelloV1>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useAppControllerGetHelloV1<TData = Awaited<ReturnType<typeof appControllerGetHelloV1>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHelloV1>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAppControllerGetHelloV1QueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const paymentControllerCreatePaymentV1 = (
    createPaymentDto: CreatePaymentDto, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PaymentResponseDto>> => {
    
    
    return axios.default.post(
      `/api/v1/payments`,
      createPaymentDto,options
    );
  }



export const getPaymentControllerCreatePaymentV1MutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentControllerCreatePaymentV1>>, TError,{data: CreatePaymentDto}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof paymentControllerCreatePaymentV1>>, TError,{data: CreatePaymentDto}, TContext> => {

const mutationKey = ['paymentControllerCreatePaymentV1'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof paymentControllerCreatePaymentV1>>, {data: CreatePaymentDto}> = (props) => {
          const {data} = props ?? {};

          return  paymentControllerCreatePaymentV1(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PaymentControllerCreatePaymentV1MutationResult = NonNullable<Awaited<ReturnType<typeof paymentControllerCreatePaymentV1>>>
    export type PaymentControllerCreatePaymentV1MutationBody = CreatePaymentDto
    export type PaymentControllerCreatePaymentV1MutationError = AxiosError<unknown>

    export const usePaymentControllerCreatePaymentV1 = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentControllerCreatePaymentV1>>, TError,{data: CreatePaymentDto}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof paymentControllerCreatePaymentV1>>,
        TError,
        {data: CreatePaymentDto},
        TContext
      > => {

      const mutationOptions = getPaymentControllerCreatePaymentV1MutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const paymentControllerGetPaymentV1 = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PaymentResponseDto>> => {
    
    
    return axios.default.get(
      `/api/v1/payments/${id}`,options
    );
  }


export const getPaymentControllerGetPaymentV1QueryKey = (id?: string,) => {
    return [`/api/v1/payments/${id}`] as const;
    }

    
export const getPaymentControllerGetPaymentV1QueryOptions = <TData = Awaited<ReturnType<typeof paymentControllerGetPaymentV1>>, TError = AxiosError<unknown>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentControllerGetPaymentV1>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPaymentControllerGetPaymentV1QueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof paymentControllerGetPaymentV1>>> = ({ signal }) => paymentControllerGetPaymentV1(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof paymentControllerGetPaymentV1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PaymentControllerGetPaymentV1QueryResult = NonNullable<Awaited<ReturnType<typeof paymentControllerGetPaymentV1>>>
export type PaymentControllerGetPaymentV1QueryError = AxiosError<unknown>


export function usePaymentControllerGetPaymentV1<TData = Awaited<ReturnType<typeof paymentControllerGetPaymentV1>>, TError = AxiosError<unknown>>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentControllerGetPaymentV1>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentControllerGetPaymentV1>>,
          TError,
          Awaited<ReturnType<typeof paymentControllerGetPaymentV1>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePaymentControllerGetPaymentV1<TData = Awaited<ReturnType<typeof paymentControllerGetPaymentV1>>, TError = AxiosError<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentControllerGetPaymentV1>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentControllerGetPaymentV1>>,
          TError,
          Awaited<ReturnType<typeof paymentControllerGetPaymentV1>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePaymentControllerGetPaymentV1<TData = Awaited<ReturnType<typeof paymentControllerGetPaymentV1>>, TError = AxiosError<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentControllerGetPaymentV1>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function usePaymentControllerGetPaymentV1<TData = Awaited<ReturnType<typeof paymentControllerGetPaymentV1>>, TError = AxiosError<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentControllerGetPaymentV1>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPaymentControllerGetPaymentV1QueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const paymentControllerUpdatePaymentDepositSelectionV1 = (
    id: string,
    updateDepositSelectionDto: UpdateDepositSelectionDto, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PaymentResponseDto>> => {
    
    
    return axios.default.patch(
      `/api/v1/payments/${id}/deposit`,
      updateDepositSelectionDto,options
    );
  }



export const getPaymentControllerUpdatePaymentDepositSelectionV1MutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentControllerUpdatePaymentDepositSelectionV1>>, TError,{id: string;data: UpdateDepositSelectionDto}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof paymentControllerUpdatePaymentDepositSelectionV1>>, TError,{id: string;data: UpdateDepositSelectionDto}, TContext> => {

const mutationKey = ['paymentControllerUpdatePaymentDepositSelectionV1'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof paymentControllerUpdatePaymentDepositSelectionV1>>, {id: string;data: UpdateDepositSelectionDto}> = (props) => {
          const {id,data} = props ?? {};

          return  paymentControllerUpdatePaymentDepositSelectionV1(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PaymentControllerUpdatePaymentDepositSelectionV1MutationResult = NonNullable<Awaited<ReturnType<typeof paymentControllerUpdatePaymentDepositSelectionV1>>>
    export type PaymentControllerUpdatePaymentDepositSelectionV1MutationBody = UpdateDepositSelectionDto
    export type PaymentControllerUpdatePaymentDepositSelectionV1MutationError = AxiosError<unknown>

    export const usePaymentControllerUpdatePaymentDepositSelectionV1 = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentControllerUpdatePaymentDepositSelectionV1>>, TError,{id: string;data: UpdateDepositSelectionDto}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof paymentControllerUpdatePaymentDepositSelectionV1>>,
        TError,
        {id: string;data: UpdateDepositSelectionDto},
        TContext
      > => {

      const mutationOptions = getPaymentControllerUpdatePaymentDepositSelectionV1MutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const alchemyControllerHandleWebhookV1 = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<null>> => {
    
    
    return axios.default.post(
      `/api/v1/providers/alchemy/webhook`,undefined,options
    );
  }



export const getAlchemyControllerHandleWebhookV1MutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof alchemyControllerHandleWebhookV1>>, TError,void, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof alchemyControllerHandleWebhookV1>>, TError,void, TContext> => {

const mutationKey = ['alchemyControllerHandleWebhookV1'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof alchemyControllerHandleWebhookV1>>, void> = () => {
          

          return  alchemyControllerHandleWebhookV1(axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AlchemyControllerHandleWebhookV1MutationResult = NonNullable<Awaited<ReturnType<typeof alchemyControllerHandleWebhookV1>>>
    
    export type AlchemyControllerHandleWebhookV1MutationError = AxiosError<unknown>

    export const useAlchemyControllerHandleWebhookV1 = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof alchemyControllerHandleWebhookV1>>, TError,void, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof alchemyControllerHandleWebhookV1>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getAlchemyControllerHandleWebhookV1MutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const testControllerCreateV1 = (
    createTestDto: CreateTestDto, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    
    
    return axios.default.post(
      `/api/v1/test`,
      createTestDto,{
        responseType: 'text',
    ...options,}
    );
  }



export const getTestControllerCreateV1MutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof testControllerCreateV1>>, TError,{data: CreateTestDto}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof testControllerCreateV1>>, TError,{data: CreateTestDto}, TContext> => {

const mutationKey = ['testControllerCreateV1'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof testControllerCreateV1>>, {data: CreateTestDto}> = (props) => {
          const {data} = props ?? {};

          return  testControllerCreateV1(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TestControllerCreateV1MutationResult = NonNullable<Awaited<ReturnType<typeof testControllerCreateV1>>>
    export type TestControllerCreateV1MutationBody = CreateTestDto
    export type TestControllerCreateV1MutationError = AxiosError<unknown>

    export const useTestControllerCreateV1 = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof testControllerCreateV1>>, TError,{data: CreateTestDto}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof testControllerCreateV1>>,
        TError,
        {data: CreateTestDto},
        TContext
      > => {

      const mutationOptions = getTestControllerCreateV1MutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const quicknodeControllerHandleWebhookV1 = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<null>> => {
    
    
    return axios.default.post(
      `/api/v1/providers/quicknode/webhook`,undefined,options
    );
  }



export const getQuicknodeControllerHandleWebhookV1MutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof quicknodeControllerHandleWebhookV1>>, TError,void, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof quicknodeControllerHandleWebhookV1>>, TError,void, TContext> => {

const mutationKey = ['quicknodeControllerHandleWebhookV1'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof quicknodeControllerHandleWebhookV1>>, void> = () => {
          

          return  quicknodeControllerHandleWebhookV1(axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type QuicknodeControllerHandleWebhookV1MutationResult = NonNullable<Awaited<ReturnType<typeof quicknodeControllerHandleWebhookV1>>>
    
    export type QuicknodeControllerHandleWebhookV1MutationError = AxiosError<unknown>

    export const useQuicknodeControllerHandleWebhookV1 = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof quicknodeControllerHandleWebhookV1>>, TError,void, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof quicknodeControllerHandleWebhookV1>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getQuicknodeControllerHandleWebhookV1MutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const walletControllerGetValidatorSchemaV1 = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<WalletControllerGetValidatorSchemaV1200>> => {
    
    
    return axios.default.get(
      `/api/v1/wallet/validator-schema`,options
    );
  }


export const getWalletControllerGetValidatorSchemaV1QueryKey = () => {
    return [`/api/v1/wallet/validator-schema`] as const;
    }

    
export const getWalletControllerGetValidatorSchemaV1QueryOptions = <TData = Awaited<ReturnType<typeof walletControllerGetValidatorSchemaV1>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof walletControllerGetValidatorSchemaV1>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getWalletControllerGetValidatorSchemaV1QueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof walletControllerGetValidatorSchemaV1>>> = ({ signal }) => walletControllerGetValidatorSchemaV1({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof walletControllerGetValidatorSchemaV1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type WalletControllerGetValidatorSchemaV1QueryResult = NonNullable<Awaited<ReturnType<typeof walletControllerGetValidatorSchemaV1>>>
export type WalletControllerGetValidatorSchemaV1QueryError = AxiosError<unknown>


export function useWalletControllerGetValidatorSchemaV1<TData = Awaited<ReturnType<typeof walletControllerGetValidatorSchemaV1>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof walletControllerGetValidatorSchemaV1>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof walletControllerGetValidatorSchemaV1>>,
          TError,
          Awaited<ReturnType<typeof walletControllerGetValidatorSchemaV1>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useWalletControllerGetValidatorSchemaV1<TData = Awaited<ReturnType<typeof walletControllerGetValidatorSchemaV1>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof walletControllerGetValidatorSchemaV1>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof walletControllerGetValidatorSchemaV1>>,
          TError,
          Awaited<ReturnType<typeof walletControllerGetValidatorSchemaV1>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useWalletControllerGetValidatorSchemaV1<TData = Awaited<ReturnType<typeof walletControllerGetValidatorSchemaV1>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof walletControllerGetValidatorSchemaV1>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useWalletControllerGetValidatorSchemaV1<TData = Awaited<ReturnType<typeof walletControllerGetValidatorSchemaV1>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof walletControllerGetValidatorSchemaV1>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getWalletControllerGetValidatorSchemaV1QueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const walletControllerGetWalletsV1 = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<null>> => {
    
    
    return axios.default.get(
      `/api/v1/wallet`,options
    );
  }


export const getWalletControllerGetWalletsV1QueryKey = () => {
    return [`/api/v1/wallet`] as const;
    }

    
export const getWalletControllerGetWalletsV1QueryOptions = <TData = Awaited<ReturnType<typeof walletControllerGetWalletsV1>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof walletControllerGetWalletsV1>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getWalletControllerGetWalletsV1QueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof walletControllerGetWalletsV1>>> = ({ signal }) => walletControllerGetWalletsV1({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof walletControllerGetWalletsV1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type WalletControllerGetWalletsV1QueryResult = NonNullable<Awaited<ReturnType<typeof walletControllerGetWalletsV1>>>
export type WalletControllerGetWalletsV1QueryError = AxiosError<unknown>


export function useWalletControllerGetWalletsV1<TData = Awaited<ReturnType<typeof walletControllerGetWalletsV1>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof walletControllerGetWalletsV1>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof walletControllerGetWalletsV1>>,
          TError,
          Awaited<ReturnType<typeof walletControllerGetWalletsV1>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useWalletControllerGetWalletsV1<TData = Awaited<ReturnType<typeof walletControllerGetWalletsV1>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof walletControllerGetWalletsV1>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof walletControllerGetWalletsV1>>,
          TError,
          Awaited<ReturnType<typeof walletControllerGetWalletsV1>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useWalletControllerGetWalletsV1<TData = Awaited<ReturnType<typeof walletControllerGetWalletsV1>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof walletControllerGetWalletsV1>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useWalletControllerGetWalletsV1<TData = Awaited<ReturnType<typeof walletControllerGetWalletsV1>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof walletControllerGetWalletsV1>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getWalletControllerGetWalletsV1QueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const walletControllerTestV1 = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<WalletControllerTestV1200>> => {
    
    
    return axios.default.get(
      `/api/v1/wallet/test`,options
    );
  }


export const getWalletControllerTestV1QueryKey = () => {
    return [`/api/v1/wallet/test`] as const;
    }

    
export const getWalletControllerTestV1QueryOptions = <TData = Awaited<ReturnType<typeof walletControllerTestV1>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof walletControllerTestV1>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getWalletControllerTestV1QueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof walletControllerTestV1>>> = ({ signal }) => walletControllerTestV1({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof walletControllerTestV1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type WalletControllerTestV1QueryResult = NonNullable<Awaited<ReturnType<typeof walletControllerTestV1>>>
export type WalletControllerTestV1QueryError = AxiosError<unknown>


export function useWalletControllerTestV1<TData = Awaited<ReturnType<typeof walletControllerTestV1>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof walletControllerTestV1>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof walletControllerTestV1>>,
          TError,
          Awaited<ReturnType<typeof walletControllerTestV1>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useWalletControllerTestV1<TData = Awaited<ReturnType<typeof walletControllerTestV1>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof walletControllerTestV1>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof walletControllerTestV1>>,
          TError,
          Awaited<ReturnType<typeof walletControllerTestV1>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useWalletControllerTestV1<TData = Awaited<ReturnType<typeof walletControllerTestV1>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof walletControllerTestV1>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useWalletControllerTestV1<TData = Awaited<ReturnType<typeof walletControllerTestV1>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof walletControllerTestV1>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getWalletControllerTestV1QueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const walletControllerCreateWebhookV1 = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<null>> => {
    
    
    return axios.default.post(
      `/api/v1/wallet/create-webhook`,undefined,options
    );
  }



export const getWalletControllerCreateWebhookV1MutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof walletControllerCreateWebhookV1>>, TError,void, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof walletControllerCreateWebhookV1>>, TError,void, TContext> => {

const mutationKey = ['walletControllerCreateWebhookV1'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof walletControllerCreateWebhookV1>>, void> = () => {
          

          return  walletControllerCreateWebhookV1(axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type WalletControllerCreateWebhookV1MutationResult = NonNullable<Awaited<ReturnType<typeof walletControllerCreateWebhookV1>>>
    
    export type WalletControllerCreateWebhookV1MutationError = AxiosError<unknown>

    export const useWalletControllerCreateWebhookV1 = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof walletControllerCreateWebhookV1>>, TError,void, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof walletControllerCreateWebhookV1>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getWalletControllerCreateWebhookV1MutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const transactionsControllerTestV1 = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<null>> => {
    
    
    return axios.default.get(
      `/api/v1/transactions/abc`,options
    );
  }


export const getTransactionsControllerTestV1QueryKey = () => {
    return [`/api/v1/transactions/abc`] as const;
    }

    
export const getTransactionsControllerTestV1QueryOptions = <TData = Awaited<ReturnType<typeof transactionsControllerTestV1>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof transactionsControllerTestV1>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTransactionsControllerTestV1QueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof transactionsControllerTestV1>>> = ({ signal }) => transactionsControllerTestV1({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof transactionsControllerTestV1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type TransactionsControllerTestV1QueryResult = NonNullable<Awaited<ReturnType<typeof transactionsControllerTestV1>>>
export type TransactionsControllerTestV1QueryError = AxiosError<unknown>


export function useTransactionsControllerTestV1<TData = Awaited<ReturnType<typeof transactionsControllerTestV1>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof transactionsControllerTestV1>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof transactionsControllerTestV1>>,
          TError,
          Awaited<ReturnType<typeof transactionsControllerTestV1>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTransactionsControllerTestV1<TData = Awaited<ReturnType<typeof transactionsControllerTestV1>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof transactionsControllerTestV1>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof transactionsControllerTestV1>>,
          TError,
          Awaited<ReturnType<typeof transactionsControllerTestV1>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTransactionsControllerTestV1<TData = Awaited<ReturnType<typeof transactionsControllerTestV1>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof transactionsControllerTestV1>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useTransactionsControllerTestV1<TData = Awaited<ReturnType<typeof transactionsControllerTestV1>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof transactionsControllerTestV1>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getTransactionsControllerTestV1QueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const assetControllerGetSupportedTokensV1 = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TokenResponseDto[]>> => {
    
    
    return axios.default.get(
      `/api/v1/assets/tokens`,options
    );
  }


export const getAssetControllerGetSupportedTokensV1QueryKey = () => {
    return [`/api/v1/assets/tokens`] as const;
    }

    
export const getAssetControllerGetSupportedTokensV1QueryOptions = <TData = Awaited<ReturnType<typeof assetControllerGetSupportedTokensV1>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof assetControllerGetSupportedTokensV1>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAssetControllerGetSupportedTokensV1QueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof assetControllerGetSupportedTokensV1>>> = ({ signal }) => assetControllerGetSupportedTokensV1({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof assetControllerGetSupportedTokensV1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AssetControllerGetSupportedTokensV1QueryResult = NonNullable<Awaited<ReturnType<typeof assetControllerGetSupportedTokensV1>>>
export type AssetControllerGetSupportedTokensV1QueryError = AxiosError<unknown>


export function useAssetControllerGetSupportedTokensV1<TData = Awaited<ReturnType<typeof assetControllerGetSupportedTokensV1>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof assetControllerGetSupportedTokensV1>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof assetControllerGetSupportedTokensV1>>,
          TError,
          Awaited<ReturnType<typeof assetControllerGetSupportedTokensV1>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAssetControllerGetSupportedTokensV1<TData = Awaited<ReturnType<typeof assetControllerGetSupportedTokensV1>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof assetControllerGetSupportedTokensV1>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof assetControllerGetSupportedTokensV1>>,
          TError,
          Awaited<ReturnType<typeof assetControllerGetSupportedTokensV1>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAssetControllerGetSupportedTokensV1<TData = Awaited<ReturnType<typeof assetControllerGetSupportedTokensV1>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof assetControllerGetSupportedTokensV1>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useAssetControllerGetSupportedTokensV1<TData = Awaited<ReturnType<typeof assetControllerGetSupportedTokensV1>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof assetControllerGetSupportedTokensV1>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAssetControllerGetSupportedTokensV1QueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const networksControllerGetNetworksV1 = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<NetworkResponseDto[]>> => {
    
    
    return axios.default.get(
      `/api/v1/networks`,options
    );
  }


export const getNetworksControllerGetNetworksV1QueryKey = () => {
    return [`/api/v1/networks`] as const;
    }

    
export const getNetworksControllerGetNetworksV1QueryOptions = <TData = Awaited<ReturnType<typeof networksControllerGetNetworksV1>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof networksControllerGetNetworksV1>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getNetworksControllerGetNetworksV1QueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof networksControllerGetNetworksV1>>> = ({ signal }) => networksControllerGetNetworksV1({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof networksControllerGetNetworksV1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type NetworksControllerGetNetworksV1QueryResult = NonNullable<Awaited<ReturnType<typeof networksControllerGetNetworksV1>>>
export type NetworksControllerGetNetworksV1QueryError = AxiosError<unknown>


export function useNetworksControllerGetNetworksV1<TData = Awaited<ReturnType<typeof networksControllerGetNetworksV1>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof networksControllerGetNetworksV1>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof networksControllerGetNetworksV1>>,
          TError,
          Awaited<ReturnType<typeof networksControllerGetNetworksV1>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useNetworksControllerGetNetworksV1<TData = Awaited<ReturnType<typeof networksControllerGetNetworksV1>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof networksControllerGetNetworksV1>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof networksControllerGetNetworksV1>>,
          TError,
          Awaited<ReturnType<typeof networksControllerGetNetworksV1>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useNetworksControllerGetNetworksV1<TData = Awaited<ReturnType<typeof networksControllerGetNetworksV1>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof networksControllerGetNetworksV1>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useNetworksControllerGetNetworksV1<TData = Awaited<ReturnType<typeof networksControllerGetNetworksV1>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof networksControllerGetNetworksV1>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getNetworksControllerGetNetworksV1QueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}
